<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Under the Hood: ls -l *.c</title>
    
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans+Arabic:wght@300;500;700&family=JetBrains+Mono:wght@400;700&family=Inter:wght@400;600;800&display=swap" rel="stylesheet">

    <style>
        /* =========================================
           VARIABLES & THEME
           ========================================= */
        :root {
            --bg-app: #030712;
            --bg-grid: rgba(255, 255, 255, 0.03);
            --bg-panel: rgba(17, 24, 39, 0.7);
            --text-primary: #f9fafb;
            --text-secondary: #9ca3af;
            --accent: #6366f1;
            --accent-glow: rgba(99, 102, 241, 0.4);
            --success: #10b981;
            --border: rgba(255, 255, 255, 0.1);
            --code-bg: #0f172a;
            --code-text: #e2e8f0; /* Default code text for Dark Mode */
            
            --font-ui: 'Inter', sans-serif;
            --font-ar: 'IBM Plex Sans Arabic', sans-serif;
            --font-code: 'JetBrains Mono', monospace;
            
            --radius: 16px;
        }

        body.light-mode {
            --bg-app: #f8fafc;
            --bg-grid: rgba(0, 0, 0, 0.03);
            --bg-panel: rgba(255, 255, 255, 0.85); /* More opaque for contrast */
            --text-primary: #0f172a;
            --text-secondary: #475569;
            --accent: #4f46e5;
            --accent-glow: rgba(79, 70, 229, 0.2);
            --border: rgba(0, 0, 0, 0.15);
            --code-bg: #f1f5f9;
            --code-text: #334155; /* Darker code text for Light Mode */
        }

        /* =========================================
           RESET & LAYOUT
           ========================================= */
        * { box-sizing: border-box; transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1); }
        
        body {
            background-color: var(--bg-app);
            background-image: 
                linear-gradient(var(--bg-grid) 1px, transparent 1px),
                linear-gradient(90deg, var(--bg-grid) 1px, transparent 1px);
            background-size: 30px 30px;
            color: var(--text-primary);
            font-family: var(--font-ui);
            margin: 0;
            min-height: 100vh;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        html[lang="ar"] body { font-family: var(--font-ar); }

        .container {
            width: 100%;
            max-width: 1100px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        /* =========================================
           HEADER
           ========================================= */
        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px 0;
        }

        .title-block h1 { margin: 0; font-size: 1.8rem; font-weight: 800; letter-spacing: -1px; }
        .title-block span { color: var(--accent); font-family: var(--font-code); background: rgba(99,102,241,0.1); padding: 2px 8px; border-radius: 6px; }
        
        .controls button {
            background: var(--bg-panel);
            border: 1px solid var(--border);
            color: var(--text-secondary);
            padding: 8px 16px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            backdrop-filter: blur(10px);
            font-family: inherit;
        }
        .controls button:hover { border-color: var(--accent); color: var(--accent); }

        /* =========================================
           DIAGRAM
           ========================================= */
        .diagram-container {
            background: var(--bg-panel);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            padding: 30px;
            overflow-x: auto;
            backdrop-filter: blur(10px);
            margin-bottom: 20px;
            text-align: center;
        }

        .flowchart {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
            min-width: 600px;
        }

        .node {
            background: var(--code-bg);
            border: 1px solid var(--border);
            padding: 10px 20px;
            border-radius: 8px;
            font-size: 0.8rem;
            font-weight: bold;
            color: var(--text-secondary);
            position: relative;
            min-width: 100px;
        }

        .node.active {
            border-color: var(--accent);
            color: var(--accent);
            box-shadow: 0 0 15px var(--accent-glow);
        }

        .arrow {
            color: var(--border);
            font-size: 1.2rem;
            display: inline-block; /* Required for transform to work */
        }
        .arrow.active { color: var(--accent); }

        /* Fix Arrow Direction in RTL */
        html[dir="rtl"] .arrow {
            transform: scaleX(-1);
        }

        /* =========================================
           MAIN DASHBOARD
           ========================================= */
        .dashboard {
            background: var(--bg-panel);
            border-radius: var(--radius);
            border: 1px solid var(--border);
            backdrop-filter: blur(12px);
            overflow: hidden;
            display: flex;
            flex-direction: column;
            min-height: 600px;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
        }

        /* Tabs */
        .tabs {
            display: flex;
            border-bottom: 1px solid var(--border);
            overflow-x: auto;
            background: rgba(0,0,0,0.2);
        }

        .tab-btn {
            padding: 15px 25px;
            background: transparent;
            border: none;
            color: var(--text-secondary);
            font-family: var(--font-code);
            font-size: 0.85rem;
            cursor: pointer;
            border-bottom: 2px solid transparent;
            white-space: nowrap;
        }

        .tab-btn:hover { color: var(--text-primary); }
        .tab-btn.active { color: var(--accent); border-bottom-color: var(--accent); background: rgba(99,102,241,0.05); }

        /* Split Content */
        .content-split {
            display: grid;
            grid-template-columns: 1.2fr 1fr;
            flex: 1;
        }

        .text-panel {
            padding: 40px;
            border-right: 1px solid var(--border);
        }

        html[dir="rtl"] .text-panel { border-right: none; border-left: 1px solid var(--border); }

        h2 { margin-top: 0; color: var(--accent); font-size: 1.5rem; display: flex; align-items: center; gap: 10px; }
        h2::before { content: '#'; opacity: 0.5; }

        p { line-height: 1.8; color: var(--text-secondary); margin-bottom: 20px; font-size: 1.05rem; }
        
        .highlight-box {
            background: rgba(16, 185, 129, 0.1);
            border: 1px solid rgba(16, 185, 129, 0.2);
            color: var(--success);
            padding: 15px;
            border-radius: 8px;
            font-size: 0.9rem;
            margin-top: 20px;
        }

        /* Code Panel */
        .code-panel {
            background: var(--code-bg);
            padding: 30px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            position: relative;
        }

        .code-header {
            position: absolute;
            top: 15px;
            right: 15px;
            font-size: 0.7rem;
            color: var(--text-secondary);
            font-family: var(--font-code);
            border: 1px solid var(--border);
            padding: 4px 8px;
            border-radius: 4px;
        }
        
        html[dir="rtl"] .code-header { right: auto; left: 15px; }

        pre {
            margin: 0;
            overflow-x: auto;
            direction: ltr;
            text-align: left;
        }

        code {
            font-family: var(--font-code);
            font-size: 0.9rem;
            line-height: 1.6;
            color: var(--code-text); /* Fixed for Light Mode */
        }
        
        /* Syntax Highlight Colors */
        .c-type { color: #c084fc; } 
        body.light-mode .c-type { color: #9333ea; }
        
        .c-func { color: #60a5fa; }
        body.light-mode .c-func { color: #2563eb; }
        
        .c-str { color: #4ade80; }
        body.light-mode .c-str { color: #16a34a; }
        
        .c-comment { color: #64748b; font-style: italic; }

        /* =========================================
           FOOTER
           ========================================= */
        footer {
            margin-top: 40px;
            text-align: center;
            color: var(--text-secondary);
            font-size: 0.9rem;
            border-top: 1px solid var(--border);
            padding-top: 20px;
            width: 100%;
        }

        /* Animation */
        .fade-enter { animation: fadeIn 0.4s ease forwards; opacity: 0; transform: translateY(5px); }
        @keyframes fadeIn { to { opacity: 1; transform: translateY(0); } }

        @media (max-width: 850px) {
            .content-split { grid-template-columns: 1fr; }
            .text-panel { border: none; border-bottom: 1px solid var(--border); }
            .diagram-container { display: none; }
        }
    </style>
</head>
<body>

<div class="container">
    
    <!-- HEADER -->
    <header>
        <div class="title-block">
            <h1 id="main-title">What happens when you type <br><span>ls -l *.c</span></h1>
        </div>
        <div class="controls">
            <button id="theme-btn">☀ Mode</button>
            <button id="lang-btn">EN / AR</button>
        </div>
    </header>

    <!-- DIAGRAM -->
    <div class="diagram-container">
        <div class="flowchart">
            <div class="node" id="node-0">STDIN</div>
            <div class="arrow">→</div>
            <div class="node" id="node-1">GETLINE</div>
            <div class="arrow">→</div>
            <div class="node" id="node-2">STRTOK</div>
            <div class="arrow">→</div>
            <div class="node" id="node-3">GLOB (*)</div>
            <div class="arrow">→</div>
            <div class="node" id="node-4">PATH</div>
            <div class="arrow">→</div>
            <div class="node" id="node-5">EXECVE</div>
            <div class="arrow">→</div>
            <div class="node" id="node-6">STDOUT</div>
        </div>
        <div id="fig-caption" style="margin-top: 15px; font-size: 0.8rem; color: var(--text-secondary); font-style: italic;">
            Figure 1: High-level overview of the shell execution pipeline.
        </div>
    </div>

    <!-- MAIN DASHBOARD -->
    <div class="dashboard">
        <!-- Tabs -->
        <div class="tabs">
            <button class="tab-btn active" data-step="0">1. Prompt & Read</button>
            <button class="tab-btn" data-step="1">2. Tokenization</button>
            <button class="tab-btn" data-step="2">3. Expansion (*)</button>
            <button class="tab-btn" data-step="3">4. Path Resolution</button>
            <button class="tab-btn" data-step="4">5. Fork & Exec</button>
        </div>

        <!-- Content -->
        <div class="content-split">
            
            <!-- Left: Explanation -->
            <div class="text-panel" id="text-output">
                <!-- Injected via JS -->
            </div>

            <!-- Right: Code -->
            <div class="code-panel">
                <div class="code-header" id="code-header-txt">C Implementation Snippet</div>
                <pre><code id="code-output">
                    <!-- Injected via JS -->
                </code></pre>
            </div>
        </div>
    </div>

    <!-- FOOTER -->
    <footer>
        <p>© 2026 Simple Shell Project. Holberton School.</p>
        <p id="authors-txt"><strong>Authors:</strong> Mohammed Saeed Al-Dosari | Yazeed Mostafa Al-Johani</p>
    </footer>

</div>

<script>
    /* =========================================
       DATA STORE (Translations)
       ========================================= */
    const uiText = {
        en: {
            title: "What happens when you type <br><span>ls -l *.c</span>",
            figure: "Figure 1: High-level overview of the shell execution pipeline.",
            codeHeader: "C Implementation Snippet",
            authors: "<strong>Authors:</strong> Mohammed Saeed Al-Dosari | Yazeed Mostafa Al-Johani",
            tabs: [
                "1. Prompt & Read",
                "2. Tokenization",
                "3. Expansion (*)",
                "4. Path Resolution",
                "5. Fork & Exec"
            ],
            nodes: ["STDIN", "GETLINE", "STRTOK", "GLOB (*)", "PATH", "EXECVE", "STDOUT"]
        },
        ar: {
            title: "ماذا يحدث عند كتابة <br><span>ls -l *.c</span>",
            figure: "شكل ١: نظرة عامة عالية المستوى لمسار تنفيذ الShell.",
            codeHeader: "مقتطف كود C (للتوضيح)",
            authors: "<strong>فريق العمل:</strong> محمد سعيد الدوسري | يزيد مصطفى الجهني",
            tabs: [
                "١. القراءة (Prompt)",
                "٢. التقطيع (Tokenize)",
                "٣. التوسيع (Expansion)",
                "٤. المسار (Path)",
                "٥. التنفيذ (Exec)"
            ],
            nodes: ["STDIN", "GETLINE", "STRTOK", "GLOB (*)", "PATH", "EXECVE", "STDOUT"]
        }
    };

    const contentData = {
        en: [
            {
                nodeId: [0, 1],
                title: "Reading from STDIN",
                text: `The process begins when the shell prints a prompt (e.g., <code>$</code>) and waits. Behind the scenes, the shell is in an infinite loop. It uses the system call <code>read()</code> or the library function <code>getline()</code> to capture characters from <strong>Standard Input (File Descriptor 0)</strong>. <br><br>The shell stores "ls -l *.c" into a buffer in memory.`,
                note: "Note: The shell blocks execution until the user presses 'Enter' (Newline).",
                code: `<span class="c-type">ssize_t</span> getline(<span class="c-type">char</span> **lineptr, <span class="c-type">size_t</span> *n, <span class="c-type">FILE</span> *stream);\n\n<span class="c-comment">/* Read input from user */</span>\nif (getline(&buffer, &bufsize, stdin) == -1)\n{\n    <span class="c-func">exit</span>(EXIT_SUCCESS);\n}`
            },
            {
                nodeId: [2],
                title: "Tokenization",
                text: `The raw string <code>"ls -l *.c"</code> is meaningless as a single unit. The shell passes this string to a lexical analyzer (tokenizer). Using <code>strtok()</code>, it splits the string by delimiters (spaces, tabs).<br><br>It creates an array of pointers: <br>1. <code>"ls"</code> (Command)<br>2. <code>"-l"</code> (Flag)<br>3. <code>"*.c"</code> (Argument)`,
                note: "Memory: The tokenizer replaces spaces with Null Bytes (\\0).",
                code: `<span class="c-type">char</span> *token;\n<span class="c-type">char</span> **argv;\n\n<span class="c-comment">/* Split string by space */</span>\ntoken = <span class="c-func">strtok</span>(buffer, " ");\n\nwhile (token != NULL)\n{\n    argv[i] = token;\n    token = <span class="c-func">strtok</span>(NULL, " ");\n}`
            },
            {
                nodeId: [3],
                title: "Wildcard Expansion (Globbing)",
                text: `<strong>This is the most critical step for this command.</strong> The <code>ls</code> program does NOT expand the asterisk (<code>*</code>). The Shell does it.<br><br>The shell detects the wildcard <code>*.c</code>. It scans the current directory using <code>opendir()</code> and <code>readdir()</code>. It looks for files ending in ".c". <br><br>It replaces <code>*.c</code> in the argument list with <code>main.c utils.c test.c</code>.`,
                note: "Fact: If no files match, the asterisk remains literal.",
                code: `<span class="c-comment">/* Logic flow for globbing */</span>\nif (<span class="c-func">strchr</span>(arg, '*') != NULL)\n{\n    <span class="c-comment">// 1. Open current directory</span>\n    <span class="c-comment">// 2. Find matching files</span>\n    <span class="c-comment">// 3. Rebuild argv array</span>\n    new_argv = { "ls", "-l", "main.c", "file.c", NULL };\n}`
            },
            {
                nodeId: [4],
                title: "Path Resolution",
                text: `The shell has the command <code>ls</code>. But the kernel needs the absolute path to execute it (e.g., <code>/bin/ls</code>).<br><br>The shell reads the <strong>PATH</strong> environment variable. It splits the PATH by colons (<code>:</code>) and appends <code>/ls</code> to each directory. It uses the syscall <code>stat()</code> to check if the file exists and is executable.`,
                note: "Result: 'ls' is resolved to '/bin/ls'.",
                code: `<span class="c-type">struct</span> stat st;\n\n<span class="c-comment">/* Loop through PATH directories */</span>\n<span class="c-func">sprintf</span>(full_path, "%s/%s", dir, command);\n\nif (<span class="c-func">stat</span>(full_path, &st) == 0)\n{\n    return (full_path); <span class="c-comment">// Found: /bin/ls</span>\n}`
            },
            {
                nodeId: [5, 6],
                title: "Fork, Execve & Wait",
                text: `The shell calls <code>fork()</code> to create a child process. The parent (Shell) calls <code>wait()</code> to pause.<br><br>The child process calls <code>execve()</code>. This syscall wipes the child's memory and loads the binary code of <code>/bin/ls</code>. The new program runs, lists the C files, prints to STDOUT, and exits. The shell then wakes up and re-prints the prompt.`,
                note: "Syscall: execve does not return on success.",
                code: `if (<span class="c-func">fork</span>() == 0)\n{\n    <span class="c-comment">/* Child: Become /bin/ls */</span>\n    <span class="c-func">execve</span>(path, argv, env);\n}\nelse\n{\n    <span class="c-comment">/* Parent: Wait for child */</span>\n    <span class="c-func">wait</span>(&status);\n}`
            }
        ],
        ar: [
            {
                nodeId: [0, 1],
                title: "قراءة المدخلات (STDIN)",
                text: `تبدأ العملية عندما تطبع الـ Shell مؤشر الكتابة (مثل <code>$</code>) وتنتظر. خلف الكواليس، تعمل الصدفة داخل حلقة لا نهائية (Infinite Loop). تستخدم استدعاء النظام <code>read()</code> أو الدالة <code>getline()</code> لالتقاط الحروف من <strong>المدخل القياسي (File Descriptor 0)</strong>.<br><br>تقوم بتخزين النص "ls -l *.c" في ذاكرة مؤقتة (Buffer).`,
                note: "ملاحظة: يتوقف البرنامج عن العمل (Blocks) حتى يضغط المستخدم على زر Enter.",
                code: `<span class="c-type">ssize_t</span> getline(<span class="c-type">char</span> **lineptr, <span class="c-type">size_t</span> *n, <span class="c-type">FILE</span> *stream);\n\n<span class="c-comment">/* قراءة المدخلات من المستخدم */</span>\nif (getline(&buffer, &bufsize, stdin) == -1)\n{\n    <span class="c-func">exit</span>(EXIT_SUCCESS);\n}`
            },
            {
                nodeId: [2],
                title: "التقطيع والتحليل (Tokenization)",
                text: `النص الخام <code>"ls -l *.c"</code> لا معنى له ككتلة واحدة. تمرر الـ Shell هذا النص إلى المحلل اللغوي (Lexer). باستخدام دالة <code>strtok()</code>، يتم تقسيم النص بناءً على الفواصل (المسافات).<br><br>النتيجة هي مصفوفة من المؤشرات:<br>1. <code>"ls"</code> (الأمر)<br>2. <code>"-l"</code> (علم/خيار)<br>3. <code>"*.c"</code> (المعامل)`,
                note: "في الذاكرة: يتم استبدال المسافات ببايتات فارغة (Null Bytes).",
                code: `<span class="c-type">char</span> *token;\n<span class="c-type">char</span> **argv;\n\n<span class="c-comment">/* تقسيم النص بالمسافات */</span>\ntoken = <span class="c-func">strtok</span>(buffer, " ");\n\nwhile (token != NULL)\n{\n    argv[i] = token;\n    token = <span class="c-func">strtok</span>(NULL, " ");\n}`
            },
            {
                nodeId: [3],
                title: "توسيع الرموز (Wildcard Expansion)",
                text: `<strong>هذه أهم خطوة لهذا الأمر تحديداً.</strong> برنامج <code>ls</code> لا يقوم بتوسيع النجمة (<code>*</code>). الـ Shell هي من تقوم بذلك.<br><br>تكتشف الـ Shell وجود الرمز <code>*.c</code>. تقوم بمسح المجلد الحالي باستخدام <code>opendir()</code> والبحث عن الملفات التي تنتهي بـ ".c".<br><br>تستبدل الـ Shell الرمز <code>*.c</code> بأسماء الملفات الحقيقية: <code>main.c test.c</code>.`,
                note: "حقيقة: إذا لم توجد ملفات مطابقة، تبقى النجمة كما هي.",
                code: `<span class="c-comment">/* منطق التوسيع (Globbing) */</span>\nif (<span class="c-func">strchr</span>(arg, '*') != NULL)\n{\n    <span class="c-comment">// 1. فتح المجلد الحالي</span>\n    <span class="c-comment">// 2. البحث عن تطابق</span>\n    <span class="c-comment">// 3. إعادة بناء المصفوفة</span>\n    new_argv = { "ls", "-l", "main.c", "file.c", NULL };\n}`
            },
            {
                nodeId: [4],
                title: "تحليل المسار (Path Resolution)",
                text: `تمتلك الـ Shell الأمر <code>ls</code>، لكن النواة (Kernel) تحتاج إلى المسار المطلق لتنفيذه (مثل <code>/bin/ls</code>).<br><br>تقرأ الـ Shell متغير البيئة <strong>PATH</strong>. تقوم بتقسيمه وتضيف <code>/ls</code> لكل مجلد. تستخدم استدعاء النظام <code>stat()</code> للتحقق من وجود الملف وقابليته للتنفيذ.`,
                note: "النتيجة: يتم تحويل 'ls' إلى '/bin/ls'.",
                code: `<span class="c-type">struct</span> stat st;\n\n<span class="c-comment">/* البحث داخل مجلدات PATH */</span>\n<span class="c-func">sprintf</span>(full_path, "%s/%s", dir, command);\n\nif (<span class="c-func">stat</span>(full_path, &st) == 0)\n{\n    return (full_path); <span class="c-comment">// تم العثور عليه: /bin/ls</span>\n}`
            },
            {
                nodeId: [5, 6],
                title: "التنفيذ (Fork, Execve, Wait)",
                text: `تستدعي الـ Shell <code>fork()</code> لإنشاء عملية ابن. العملية الأب (Shell) تستدعي <code>wait()</code> للتوقف.<br><br>العملية الابن تستدعي <code>execve()</code>. هذا النظام يقوم بمسح ذاكرة الابن وتحميل الكود الثنائي لبرنامج <code>/bin/ls</code>. يعمل البرنامج، يسرد ملفات C، يطبع للـ STDOUT، ثم يخرج. تستيقظ الـ Shell وتعيد طباعة المؤشر.`,
                note: "نظام Execve لا يعود (Return) في حالة النجاح.",
                code: `if (<span class="c-func">fork</span>() == 0)\n{\n    <span class="c-comment">/* الابن: يتحول إلى /bin/ls */</span>\n    <span class="c-func">execve</span>(path, argv, env);\n}\nelse\n{\n    <span class="c-comment">/* الأب: ينتظر الابن */</span>\n    <span class="c-func">wait</span>(&status);\n}`
            }
        ]
    };

    /* =========================================
       LOGIC
       ========================================= */
    let currentStep = 0;
    let currentLang = 'en'; 
    let isLightMode = false;

    // Elements
    const textOutput = document.getElementById('text-output');
    const codeOutput = document.getElementById('code-output');
    const tabBtns = document.querySelectorAll('.tab-btn');
    const nodes = document.querySelectorAll('.node');
    const arrows = document.querySelectorAll('.arrow');
    const mainTitle = document.getElementById('main-title');
    const figCaption = document.getElementById('fig-caption');
    const codeHeaderTxt = document.getElementById('code-header-txt');
    const authorsTxt = document.getElementById('authors-txt');

    function updateStaticUIText() {
        const t = uiText[currentLang];
        mainTitle.innerHTML = t.title;
        figCaption.innerHTML = t.figure;
        codeHeaderTxt.innerHTML = t.codeHeader;
        authorsTxt.innerHTML = t.authors;

        // Update Tabs Text
        tabBtns.forEach((btn, index) => {
            if(t.tabs[index]) btn.innerText = t.tabs[index];
        });

        // Update Node Text
        nodes.forEach((node, index) => {
            if(t.nodes[index]) node.innerText = t.nodes[index];
        });
    }

    function render() {
        // 1. Get Content
        const content = contentData[currentLang][currentStep];

        // 2. Animate & Render Text
        textOutput.classList.remove('fade-enter');
        void textOutput.offsetWidth; // trigger reflow
        textOutput.innerHTML = `
            <div class="fade-enter">
                <h2>${content.title}</h2>
                <p>${content.text}</p>
                <div class="highlight-box">${content.note}</div>
            </div>
        `;
        textOutput.classList.add('fade-enter');

        // 3. Render Code
        codeOutput.innerHTML = content.code;

        // 4. Update Tabs Active State
        tabBtns.forEach((btn, idx) => {
            btn.classList.toggle('active', idx === currentStep);
        });

        // 5. Update Flowchart Visuals
        nodes.forEach(n => n.classList.remove('active'));
        arrows.forEach(a => a.classList.remove('active'));
        
        // Highlight logic for diagram
        content.nodeId.forEach(id => {
            const node = document.getElementById(`node-${id}`);
            if(node) node.classList.add('active');
            
            // Highlight previous arrows
            for(let i=0; i<id; i++) {
                if(arrows[i]) arrows[i].classList.add('active');
            }
        });
    }

    function setStep(index) {
        currentStep = index;
        render();
    }

    // Tabs Click Listeners
    tabBtns.forEach((btn, index) => {
        btn.addEventListener('click', () => setStep(index));
    });

    // Language Toggle
    document.getElementById('lang-btn').addEventListener('click', () => {
        currentLang = currentLang === 'en' ? 'ar' : 'en';
        document.documentElement.setAttribute('dir', currentLang === 'ar' ? 'rtl' : 'ltr');
        document.documentElement.setAttribute('lang', currentLang);
        
        updateStaticUIText(); // Update titles/labels
        render(); // Update content area
    });

    // Theme Toggle
    document.getElementById('theme-btn').addEventListener('click', () => {
        isLightMode = !isLightMode;
        if(isLightMode) document.body.classList.add('light-mode');
        else document.body.classList.remove('light-mode');
    });

    // Initial Render
    updateStaticUIText();
    render();

</script>
</body>
</html>
